# 阻塞解决方案

### 1."线程池"

线程池旨在减少创建和销毁线程的频率,其维持一定合理数量的线程,并让空闲的线程重新承担新的执行任务."连接池"是维持连接的缓存池,尽量重用已有的连接,减少创建和关闭连接的频率.

"线程池"和"连接池"技术都可以很好的降低系统开销,被广泛应用在很多大型系统中,如:WebSphere,Tomcat和各种数据库等.

但是,"线程池"和"连接池"技术也只是在一定程度上缓解了频繁调用I/O接口带来的资源占用.而且,所谓"池"始终有上限,当请求大大超过上限时,"池"构成的系统对外界的响应并不比没有池的时候效果好多少.所以使用"池"必须考虑其面临的响应规模,并根据响应规模调整"池"的大小.

**这里我们面临的连接非常多,因此线程池和连接池并不能解决所有问题**



### 2.非阻塞的服务器程序

非阻塞接口相比于阻塞型接口的显著差异在于:再被调用之后立即返回.

fcnt1(fd,F_SETFL,O_NONBLOCK);可以设置句柄fd为非阻塞状态.

非阻塞状态下;

recv()接口在被调用后立即返回,返回值代表不同的含义;

recv()大于0,表示数据接受完毕,返回值即是接收到的字节数.返回0 ,表示连接已经正常断开,返回-1,且error等于EAGAIN,表示recv操作还没有执行完,返回-1,且error不等于EAGAIN,表示recv操作遇到系统错误errno.

服务器线程可以通过循环调用recv()接口,可以在单个线程内实现对所有连接的数据接收工作.

但是这种方法很不推荐,因为循环调用recv()将大幅提高CPU的占有率,更多的起到"操作是否完成"的作用,实际操作系统提供了更为搞笑的检测操作是否完成作用的接口,如select()

select()模型就不讲了,这里重点介绍一下epoll实现的异步事件通知模型.



### 3.epoll 异步事件通知模型

epoll 的两种模式:LT和ET

两者的差异在于LT水平触发模式下只要某个Socket处于readable/writable状态,无论什么时候进行epoll_wait都会返回该socket,而ET边缘触发模式下只有某个socket从unreadable变化readable或从unwritable变为writable,epoll_wait才会返回该socket.

所以epoll的ET边缘模式下,正确的读写方式如下:

1.读;只要可读,就一直读,直到返回0,或者errno=EAGAIN.

2.写;只要可写,就一直写,直到数据发送完,或者errno=EAGAIN



accept()技巧

1.阻塞模式accept存在的问题:考虑这种情况,TCP连接被客户端夭折,即在调用accept()之前,客户端主动发送RST终止连接,导致刚刚建立的连接就从就绪队列中移除,如果套接口被设置成阻塞模式,服务器就会一直阻塞在accept调用上,直到其他某个客户端建立一个新的连接为止.但是在此期间,服务器单纯地阻塞在accept调用上,就绪队列中的其他描述符都得不到处理.

**解决办法**:把监听套接口设置为非阻塞,当客户端在服务器调用accept之前终止某个连接时,accept调用可以立即返回-1,这时源自Berkeley的实现会在内核中处理该事件,并不会将事件通知给epoll,而其他errno设置为ECONNABORTED或者EPROTO错误,我们应该忽略这两个错误.

2.ET模式下accept存在的问题,**考虑这种情况**:多个连接同时到达,服务器的TCP就绪队列瞬间积累多个就绪连接,由于是ET边缘出发模式,epoll只会通知一次,accept只处理一次连接,导致TCP就绪队列中剩下的队列得不到处理.

**解决办法**:用while循环包住accept调用,处理完TCP就绪队列中的所有连接后再退出循环,如何直到是否处理玩就绪队列中的所有连接呢,accept返回-1并且errno设置为EAGAIN就表示所有连接都处理完.